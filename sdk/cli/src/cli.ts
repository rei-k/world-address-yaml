#!/usr/bin/env node
/**
 * veyform-sdk CLI
 */

import { Command } from 'commander';
import * as fs from 'fs';
import * as path from 'path';

const program = new Command();

program
  .name('veyform-sdk')
  .description('CLI tool for Vey World Address SDK')
  .version('1.0.0');

// Init command
program
  .command('init')
  .description('Initialize Vey SDK in your project')
  .option('-f, --framework <framework>', 'Framework to use (react, vue, angular, svelte)', 'react')
  .option('--typescript', 'Use TypeScript', true)
  .action((options) => {
    console.log('üöÄ Initializing Vey SDK...');
    console.log(`   Framework: ${options.framework}`);
    console.log(`   TypeScript: ${options.typescript}`);

    // Create .env.example
    const envContent = `# Vey SDK Configuration
VEY_API_KEY=your-api-key-here
VEY_ENVIRONMENT=sandbox
`;

    fs.writeFileSync('.env.example', envContent);
    console.log('‚úÖ Created .env.example');

    // Create basic config file
    const configContent = `/**
 * Vey SDK Configuration
 */
export const veyConfig = {
  apiKey: process.env.VEY_API_KEY || '',
  environment: (process.env.VEY_ENVIRONMENT || 'sandbox') as 'sandbox' | 'production',
};
`;

    const configPath = options.typescript ? 'vey.config.ts' : 'vey.config.js';
    fs.writeFileSync(configPath, configContent);
    console.log(`‚úÖ Created ${configPath}`);

    console.log('\nüì¶ Next steps:');
    console.log(`   1. Install dependencies: npm install @vey/core @vey/${options.framework}`);
    console.log('   2. Copy .env.example to .env and add your API key');
    console.log('   3. Import and use the SDK in your project');
  });

// cURL command generator
program
  .command('curl')
  .description('Generate cURL commands for Vey API')
  .option('--event <event>', 'Webhook event type', 'address-update')
  .option('--url <url>', 'Webhook URL', 'https://your-server.com/webhook')
  .action((options) => {
    console.log('üîó Generated cURL command:\n');

    const curlCommand = `curl -X POST "${options.url}" \\
  -H "Content-Type: application/json" \\
  -H "X-Vey-Signature: sha256=..." \\
  -d '{
    "event": "${options.event}",
    "timestamp": "${new Date().toISOString()}",
    "data": {
      "address_id": "addr_123456",
      "changes": {
        "city": "Tokyo"
      }
    }
  }'`;

    console.log(curlCommand);
  });

// Validate address command
program
  .command('validate')
  .description('Validate an address')
  .requiredOption('-c, --country <code>', 'Country code (e.g., JP, US)')
  .option('--postal-code <code>', 'Postal code')
  .option('--city <city>', 'City name')
  .option('--province <province>', 'Province/State')
  .action(async (options) => {
    console.log('üîç Validating address...');
    console.log(`   Country: ${options.country}`);
    if (options.postalCode) console.log(`   Postal Code: ${options.postalCode}`);
    if (options.city) console.log(`   City: ${options.city}`);
    if (options.province) console.log(`   Province: ${options.province}`);
    console.log('\n‚úÖ Validation complete');
  });

// Generate GraphQL schema
program
  .command('graphql')
  .description('Generate GraphQL schema for address types')
  .option('-o, --output <file>', 'Output file', 'schema.graphql')
  .action((options) => {
    console.log('üìù Generating GraphQL schema...');

    const schema = `# Generated by veyform-sdk
# Vey Address GraphQL Schema

"""
Address input for validation and storage
"""
input AddressInput {
  recipient: String
  building: String
  floor: String
  room: String
  unit: String
  streetAddress: String
  district: String
  ward: String
  city: String
  province: String
  postalCode: String
  country: String!
}

"""
Validated address with normalized fields
"""
type Address {
  id: ID!
  recipient: String
  building: String
  floor: String
  room: String
  unit: String
  streetAddress: String
  district: String
  ward: String
  city: String
  province: String
  postalCode: String
  country: String!
  formatted: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
Address validation result
"""
type ValidationResult {
  valid: Boolean!
  errors: [ValidationError!]!
  warnings: [ValidationWarning!]!
  normalized: Address
}

type ValidationError {
  field: String!
  code: String!
  message: String!
}

type ValidationWarning {
  field: String!
  code: String!
  message: String!
}

"""
Country address format configuration
"""
type CountryFormat {
  countryCode: String!
  countryName: String!
  requiredFields: [String!]!
  fieldOrder: [String!]!
  postalCodePattern: String
  postalCodeExample: String
}

"""
Delivery tracking information
"""
type DeliveryStatus {
  id: ID!
  addressId: ID!
  carrier: String!
  trackingNumber: String
  status: DeliveryStatusEnum!
  estimatedDelivery: DateTime
  updatedAt: DateTime!
}

enum DeliveryStatusEnum {
  PENDING
  PICKED_UP
  IN_TRANSIT
  OUT_FOR_DELIVERY
  DELIVERED
  FAILED
}

"""
Locker location for pickup
"""
type Locker {
  id: ID!
  name: String!
  address: Address!
  availability: LockerAvailability!
}

enum LockerAvailability {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
}

type Query {
  """
  Get address by ID
  """
  address(id: ID!): Address

  """
  Validate an address
  """
  validateAddress(input: AddressInput!, countryCode: String!): ValidationResult!

  """
  Get country address format
  """
  countryFormat(countryCode: String!): CountryFormat

  """
  Get all supported countries
  """
  countries: [CountryFormat!]!

  """
  Get delivery status
  """
  deliveryStatus(id: ID!): DeliveryStatus

  """
  Find nearby lockers
  """
  nearbyLockers(latitude: Float!, longitude: Float!, radius: Float): [Locker!]!
}

type Mutation {
  """
  Create a new address
  """
  createAddress(input: AddressInput!): Address!

  """
  Update an existing address
  """
  updateAddress(id: ID!, input: AddressInput!): Address!

  """
  Delete an address
  """
  deleteAddress(id: ID!): Boolean!
}

type Subscription {
  """
  Subscribe to address updates
  """
  addressUpdated(id: ID!): Address!

  """
  Subscribe to delivery status changes
  """
  deliveryStatusChanged(addressId: ID!): DeliveryStatus!
}

scalar DateTime
`;

    fs.writeFileSync(options.output, schema);
    console.log(`‚úÖ Generated GraphQL schema: ${options.output}`);
  });

// Generate gRPC proto
program
  .command('proto')
  .description('Generate gRPC proto file for address services')
  .option('-o, --output <file>', 'Output file', 'vey.proto')
  .action((options) => {
    console.log('üìù Generating gRPC proto...');

    const proto = `// Generated by veyform-sdk
// Vey Address gRPC Protocol Buffer Definition

syntax = "proto3";

package vey.address.v1;

option go_package = "github.com/vey/address/v1";

// Address service for validation and management
service AddressService {
  // Validate an address
  rpc ValidateAddress(ValidateAddressRequest) returns (ValidateAddressResponse);
  
  // Get address by ID
  rpc GetAddress(GetAddressRequest) returns (Address);
  
  // Create a new address
  rpc CreateAddress(CreateAddressRequest) returns (Address);
  
  // Update an existing address
  rpc UpdateAddress(UpdateAddressRequest) returns (Address);
  
  // Delete an address
  rpc DeleteAddress(DeleteAddressRequest) returns (DeleteAddressResponse);
  
  // Get country format configuration
  rpc GetCountryFormat(GetCountryFormatRequest) returns (CountryFormat);
  
  // Stream address updates
  rpc StreamAddressUpdates(StreamAddressUpdatesRequest) returns (stream AddressUpdate);
}

// Delivery service for tracking
service DeliveryService {
  // Get delivery status
  rpc GetDeliveryStatus(GetDeliveryStatusRequest) returns (DeliveryStatus);
  
  // Stream delivery updates
  rpc StreamDeliveryUpdates(StreamDeliveryUpdatesRequest) returns (stream DeliveryStatus);
}

// Locker service for pickup locations
service LockerService {
  // Find nearby lockers
  rpc FindNearbyLockers(FindNearbyLockersRequest) returns (FindNearbyLockersResponse);
  
  // Get locker details
  rpc GetLocker(GetLockerRequest) returns (Locker);
}

// Address input message
message AddressInput {
  string recipient = 1;
  string building = 2;
  string floor = 3;
  string room = 4;
  string unit = 5;
  string street_address = 6;
  string district = 7;
  string ward = 8;
  string city = 9;
  string province = 10;
  string postal_code = 11;
  string country = 12;
}

// Full address with metadata
message Address {
  string id = 1;
  string recipient = 2;
  string building = 3;
  string floor = 4;
  string room = 5;
  string unit = 6;
  string street_address = 7;
  string district = 8;
  string ward = 9;
  string city = 10;
  string province = 11;
  string postal_code = 12;
  string country = 13;
  string formatted = 14;
  int64 created_at = 15;
  int64 updated_at = 16;
}

// Validation error
message ValidationError {
  string field = 1;
  string code = 2;
  string message = 3;
}

// Validation warning
message ValidationWarning {
  string field = 1;
  string code = 2;
  string message = 3;
}

// Country format configuration
message CountryFormat {
  string country_code = 1;
  string country_name = 2;
  repeated string required_fields = 3;
  repeated string field_order = 4;
  string postal_code_pattern = 5;
  string postal_code_example = 6;
}

// Delivery status
message DeliveryStatus {
  string id = 1;
  string address_id = 2;
  string carrier = 3;
  string tracking_number = 4;
  DeliveryStatusEnum status = 5;
  int64 estimated_delivery = 6;
  int64 updated_at = 7;
}

enum DeliveryStatusEnum {
  DELIVERY_STATUS_UNSPECIFIED = 0;
  DELIVERY_STATUS_PENDING = 1;
  DELIVERY_STATUS_PICKED_UP = 2;
  DELIVERY_STATUS_IN_TRANSIT = 3;
  DELIVERY_STATUS_OUT_FOR_DELIVERY = 4;
  DELIVERY_STATUS_DELIVERED = 5;
  DELIVERY_STATUS_FAILED = 6;
}

// Locker information
message Locker {
  string id = 1;
  string name = 2;
  Address address = 3;
  LockerAvailability availability = 4;
}

enum LockerAvailability {
  LOCKER_AVAILABILITY_UNSPECIFIED = 0;
  LOCKER_AVAILABILITY_AVAILABLE = 1;
  LOCKER_AVAILABILITY_OCCUPIED = 2;
  LOCKER_AVAILABILITY_MAINTENANCE = 3;
}

// Address update event
message AddressUpdate {
  string address_id = 1;
  string event_type = 2;
  Address address = 3;
  int64 timestamp = 4;
}

// Request/Response messages
message ValidateAddressRequest {
  AddressInput address = 1;
  string country_code = 2;
}

message ValidateAddressResponse {
  bool valid = 1;
  repeated ValidationError errors = 2;
  repeated ValidationWarning warnings = 3;
  Address normalized = 4;
}

message GetAddressRequest {
  string id = 1;
}

message CreateAddressRequest {
  AddressInput address = 1;
}

message UpdateAddressRequest {
  string id = 1;
  AddressInput address = 2;
}

message DeleteAddressRequest {
  string id = 1;
}

message DeleteAddressResponse {
  bool success = 1;
}

message GetCountryFormatRequest {
  string country_code = 1;
}

message StreamAddressUpdatesRequest {
  repeated string address_ids = 1;
}

message GetDeliveryStatusRequest {
  string id = 1;
}

message StreamDeliveryUpdatesRequest {
  string address_id = 1;
}

message FindNearbyLockersRequest {
  double latitude = 1;
  double longitude = 2;
  double radius_km = 3;
}

message FindNearbyLockersResponse {
  repeated Locker lockers = 1;
}

message GetLockerRequest {
  string id = 1;
}
`;

    fs.writeFileSync(options.output, proto);
    console.log(`‚úÖ Generated gRPC proto: ${options.output}`);
  });

// List countries command
program
  .command('countries')
  .description('List supported countries')
  .option('--region <region>', 'Filter by region (asia, europe, americas, etc.)')
  .action((options) => {
    console.log('üåç Supported Countries:\n');

    const countries = [
      { code: 'JP', name: 'Japan', region: 'Asia' },
      { code: 'CN', name: 'China', region: 'Asia' },
      { code: 'KR', name: 'South Korea', region: 'Asia' },
      { code: 'US', name: 'United States', region: 'Americas' },
      { code: 'CA', name: 'Canada', region: 'Americas' },
      { code: 'GB', name: 'United Kingdom', region: 'Europe' },
      { code: 'DE', name: 'Germany', region: 'Europe' },
      { code: 'FR', name: 'France', region: 'Europe' },
      { code: 'AU', name: 'Australia', region: 'Oceania' },
    ];

    const filtered = options.region
      ? countries.filter((c) => c.region.toLowerCase() === options.region.toLowerCase())
      : countries;

    filtered.forEach((c) => {
      console.log(`   ${c.code} - ${c.name} (${c.region})`);
    });

    console.log(`\n   Total: ${filtered.length} countries`);
  });

program.parse();
